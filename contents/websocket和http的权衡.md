websocket 的特色是主动推送以及广播效果，效果比 http 轮询要好。

传输格式上，http 目前只支持文本，还要携带 header 和 cookie，而 websocket 可以支持传输二进制数据，可以利用 protobuf 等压缩 size，所以传输的量 websocket 明显小于 http。

传输大量内容时，例如文件上传，如果使用 websocket，会阻塞其它数据的传输，这种情况使用 http 要更好一些。使用 http 获取数据时，可以利用浏览器的缓存机制，避免重复下载。

websocket 的浏览器支持程度是，>=IE10，不过可以使用 socket.io 等库，来支持低版本的浏览器。

一个小特点是，websocket 是不受同源策略限制的。

模型上 http 是请求－响应模型，而 websocket 是基于事件的的模型，发出消息后，不一定会有对应的响应，也可能有多个响应。
实际使用时，http 类似于常规的接口同步调用，服务端无状态，客户端有状态，收到响应时有请求时的 context，知道是哪个请求的结果，而 websocket 不是这样，服务端有状态，有连接时就产生的 context，客户端没有局部状态，发送消息时的 context 可以保存在消息中，也可以保存在全局的 hash 结构中，在各个事件中，从消息体中，或者全局的 hash 结构中，恢复出消息发送时的 context，执行相应的操作。
这样消息的发出和接收不再一一对应，也就完全解藕出来。
对于具体的命令，可以默认它成功，如果出现错误时，推送这个错误通知，并还原消耗的资源。
对于查询，可以做成连接时主动返回的形式，在变更时，主动通知变更后的结果，使开发模型更简单。
另外某些情况下，可以把客户端的定时转移到服务端，定时查询并组合数据后，统一推送，从而使系统负载更低。

设计 http 接口时，需要从资源的增删改查角度设计，服务端驱动。
设计 websocket 接口时，需要从客户端需要的事件角度设计，客户端驱动。

最后给出一个例子，某个用户用自己的积分，换取某个物品：
如果使用 http，客户端在请求时，扣除积分，并携带 token，成功后加入仓库，失败后恢复积分，并提示错误原因。
如果使用 websocket，客户端在发送消息时，扣除积分，（不需要携带 token，服务端也不需要验证，因为服务端是有状态的，连接时已经验证过了），成功后在仓库更新事件收到消息，把物品加入仓库，失败后在积分更新事件收到消息，更新积分，在消息提示事件收到消息，提示错误消息。

结论，http 和 websocket 有各自的用武之地，完全不同的编程模型，结合着使用，可以发挥完美的效果。

另外，通过 websocket 连接，可以使用传统的 json-rpc，宏观上类似于方法调用，但是实现时，如果不借助第三方库，客户端需要生成不重复的 id，并在收到消息时，匹配消息的 id 和已发出的消息的 id，还要管理已发出消息的请求的生命周期，会更复杂一些。