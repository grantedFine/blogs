### 责任

在较大的团队，会比较注重划分责任、事后追责。

目前的方法是为每个人都拆分了单独的仓库，各个仓库的责任都在开发者身上，缺点在于：

1. 仓库间复杂的调用关系降低开发效率，简单的功能都需要多个仓库协同开发
2. 开发完成后，联调的工作量增加了，沟通成本也增加了
3. 部署时，因为复杂的依赖关系，增加了部署工作量

而统一的仓库显著的会解决上面的缺点，至于开发责任，由git blame和pull request机制来解决。

git blame用来查询代码的提交历史，可以用来追责，而在pull request工作流中，责任存在于merger，而不是具体的开发者，这对于merger要求很高，既要能完成自己的任务，也要能够承担review的责任。

### 代码规范

较大的团队也有统一代码规范的需求。

目前的方法是，统一一个代码规范，但是执行并不到位，对于一些命名和缩写相关的统一需求，需要面对面沟通。

这种方法的缺点就是沟通成本高。

对于一般的代码规范需求，例如代码格式，可以采用代码格式工具进行检查，配合CI，可以在pull request上显示待merge的代码是否复合规定的格式，从而减少的沟通。

在本地开发环境，也应该有统一的检查工具，在提交pull request之前就运行检查。

对于代码检查工具涉及不到的领域，例如命名，可以在review阶段设计多个reviewer提供才能merge的机制，对代码检查工具涉及不到的领域，在review阶段就能发现，不需要额外的沟通。

### 协议和文档

目前的做法是，要么缺少文档，要么不够明晰，例如对于http接口，只确定了method、url、body里的字段，没有确定content-type，再例如长连接里的消息，只确定了有哪些字段，没有确定具体是什么模型、具体的二进制数据模型。

其实文档是解决团队沟通问题的一个重要的方法，项目入口需要有安装、启动、初始化文档，组件需要有使用文档、暴露的类、方法、模型的说明，通信要有基于通信协议的文档、规定好传输数据的格式。

有了文档之后，不会有新的开发者加入后，都要问一下项目怎么启动，也不会有开发者要使用组件后，都要问一下某个参数是什么意思，也不会花大量的时间在联调上，双方都按照确定好的通信协议和格式开发，最后在统一测试一遍就好。

不过这样对开发者的额能力有要求，要能够熟悉各种通信协议，知道设计好用的组件、接口，而不是只会调用封装好的库，不理解库内部具体的实现。

### 组件拆分

目前的做法是，拆分的很细，而且不是每次更新都会更新版本号，结果版本依赖关系更加复杂。

更好的做法是统一仓库，只有一个主仓库，对于相对独立、可以复用的组件，才会被放到独立的仓库（抽取出来时，需要以调用过程为原型，写可复用组件的单元测试），而且所有的组件都实现语义化版本规则，break change时组件主版本号，功能增加但不是break change时增加辅助版本号，当只是小的bug修复而且不是break change时，增加第3位的版本号，每次release都要改变版本号。
