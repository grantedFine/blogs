# 测试策略总结

## 公共库

这里指对外提供 function 或 class 的库，供调用者直接调用

因为输入和输出简单，最好采用传统的**单元测试**，根据各个 corner case，构建测试用例，并验证预期的结果

如果库的内部使用了浏览器接口，可以使用 karma 等在浏览器中进行测试

## CLI 程序

如果需要文件输入或者 API 操作，在测试开始时，需要先**准备好 mock 文件或 mock 服务**。

CLI 执行结束后，对于 stdout 和 stderr，或者生成的文件，可以**以文件的形式作为测试的 baseline，加入到源代码管理中，在 CI 中也验证 baseline 是否一致**，这样比传统的单元测试验证更直观

## UI 组件

根据各个 corner case，创建测试用例

在测试开始前，**启动静态文件服务器**，同时**启动 headless 浏览器，分别访问各个测试用例页面，截图保存，取 html 内容并以文件的形式保存，都作为测试的 baseline，加入到源代码管理中，在 CI 中也验证 baseline 是否一致**

## 纯前端程序

在测试开始前，**启动静态文件服务器**，同时**启动 headless 浏览器，访问待测试的页面，截图保存，取 html 内容并以文件的形式保存，都作为测试的 baseline，加入到源代码管理中，在 CI 中也验证 baseline 是否一致**

## 纯后端程序

这里是指只对外提供 API 的后端程序

测试时，启动后端程序，根据各个 use case，安装数据库、redis 等依赖的服务并初始化数据，根据 API，构造请求，并对响应进行验证

测试数据可以通过 mock 库（例如 faker.js）来生成

## 前后端混合程序

测试时，启动后端程序，根据各个 use case，安装数据库、redis 等依赖的服务并初始化数据，启动 headless 浏览器，访问各个页面，截图保存，取 html 内容并以文件的形式保存，都作为测试的 baseline，加入到源代码管理中，在 CI 中也验证 baseline 是否一致

## 关于截图

在不同的操作系统中，对字体的渲染会有细微差别，这可能会导致 build 时的截图和 CI 时的截图不一致

所以最好要使用统一的操作系统，否则可以在 CI 中不对截图进行验证

## **测试**是一个关于**表达**的问题

用简单的形式，清晰地表达代码的功能、界面改动效果等等。
