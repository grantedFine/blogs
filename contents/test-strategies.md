# 测试策略总结

## 公共库

这里指对外提供 function 或 class 的库，供调用者直接调用

因为输入和输出简单，最好采用传统的**单元测试**，根据各个 corner case，构建测试用例，并验证预期的结果

如果库的内部使用了浏览器接口，可以使用 karma 等在浏览器中进行测试

## CLI 程序

如果需要文件输入或者 API 操作，在测试开始时，需要先**准备好 mock 文件或 mock 服务**。

CLI 执行结束后，对于 stdout 和 stderr，或者生成的文件，可以**以文件的形式作为测试的 baseline，加入到源代码管理中，在 CI 中也验证 baseline 是否一致**，这样比传统的单元测试验证更直观

## UI 组件

根据各个 corner case，创建测试用例

在测试开始前，**启动静态文件服务器**，同时**启动 headless 浏览器，分别访问各个测试用例页面，截图保存，取 html 内容并以文件的形式保存，都作为测试的 baseline，加入到源代码管理中，在 CI 中也验证 baseline 是否一致**

## 纯前端程序

在测试开始前，**启动静态文件服务器**，同时**启动 headless 浏览器，访问待测试的页面，截图保存，取 html 内容并以文件的形式保存，都作为测试的 baseline，加入到源代码管理中，在 CI 中也验证 baseline 是否一致**

## 纯后端程序

这里是指只对外提供 API 的后端程序

测试时，启动后端程序，根据各个 use case，安装数据库、redis 等依赖的服务并初始化数据，根据 API，构造请求，并对响应进行验证

测试数据可以通过 mock 库（例如 faker.js）来生成

## 前后端混合程序

测试时，启动后端程序，根据各个 use case，安装数据库、redis 等依赖的服务并初始化数据，启动 headless 浏览器，访问各个页面，截图保存，取 html 内容并以文件的形式保存，都作为测试的 baseline，加入到源代码管理中，在 CI 中也验证 baseline 是否一致

## 关于截图

在不同的操作系统中，对字体的渲染会有细微差别，这可能会导致 build 时的截图和 CI 时的截图不一致

所以最好要使用统一的操作系统，否则可以在 CI 中不对截图进行验证

## 框架相关的组件测试

+ vuejs: vue-test-utils
+ reactjs: react-dom/test-utils react-test-renderer enzyme
+ angular: @angular/core/testing

虽然各个框架使用的测试工具都不一样，但是还是有一些相同的地方：

+ 为了能够操作 DOM，一般要通过 karma 等工具使测试用例运行在浏览器上
+ 针对组件进行测试，测试用例开始时创建组件的实例，结束前销毁

## **测试**是一个关于**表达**的问题

用简单的形式，清晰地表达代码的功能、界面改动效果等等。

## 没有测试结果的情况

某些待测试代码并没有返回值，这时可以在待测试代码里的关键位置增加 debug 信息的收集，把代码执行过程中收集到的 debug 信息返回作为测试结果

## 测试的目的：防止未来的自己或其他人修改代码时 break 已有的功能，保证程序稳定性

所以，测试结果是否正确不重要，测试结果没变化才重要。（集成测试通过后，就可以认为测试结果是正确的）

因为 snapshot 测试会自动生成、更新测试结果，使用起来更方便

## 测试策略

### 先写完功能，在等待联调或集成测试结果的时候，补充相应的测试代码

这样可以同时保证开发速度和稳定性

如果现有的代码不方便测试，可以 refactor 为更 pure 的代码，以方便测试，例如：

```ts
// 重构前
function foo() {
    return Math.random() > 0.2 : 1 : 0
}

// 重构后
function foo(getRandom: () => number) {
    return getRandom() > 0.2 : 1 : 0
}
// 测试
foo(() => 0)
foo(() => 0.5)
```

### 为主流程增加一个测试用例

例如对于一个包含前后端的程序，需要有一个同时测试前后端的集成测试用例

### 对于分支流程，只对分支流程所在的测试单元进行测试

例如对于后端的一个分支，需要有一个只测试后端 API（如果粒度更细的话，可以测试后端代码中的那个函数） 的测试用例来测试这个分支流程

这样相比完全的集成测试，可以大幅减少测试的复杂度、运行时间

如果分支流程所在的测试单元耦合严重，需要进行重构抽出新的测试单元后再进行测试

### 对于后续维护发现的 BUG，在提交修复代码的 PR 里，也要同时包含相应的测试代码
