## WeakMap

一个特殊的map结果，key只能是引用类型，当某个key没有被引用后，会被GC自动情理掉

```
const weakmap = new WeakMap();
function f(){
    let a = { b: 1};
    weakmap.set(a, 2);
    console.log(weakmap); // WeakMap {Object {b: 1} => 2}
}
f();
// after a while
console.log(weakmap); // WeakMap {}
```

## web audio api

js可以处理音频源（滤波、音量、延时、混响），可以实现不依赖网络延迟的音频播放

## html lint

还没有支持模板自定义tag、attr的工具

## headless chrome

替代PhantomJS，用来测试前端界面、制作爬虫

## flow type

支持的编辑器少

## css3 animation keyframes

一个缺点是，keyframes中的值不能被js动态修改，只能创建style元素，覆盖原来的keyframes。

而这种方式会生成内联的css，不能和style-src 'unsafe-inline'兼容，所以可能存在安全问题。

## GraphQL

特点是由客户端决定返回哪些数据，适合要求API有强扩展性的场景。

缺点是，每个field都单独resolve，性能低，需要使用loader来提高性能；例外query可以无限嵌套，为了防止导致耗尽资源，需要有请求的资源耗用监视机制。

## chrome devtools audits 去除无用css

只会识别当前使用的css，只适合没有交互的简单页面。

## prepack

是js to js的代码优化工具；

产生的代码体积可能会变大；

对于不纯粹的代码，例如涉及到dom操作，还不可用；

生成的代码虽然性能更高，可能可读性变差、调试变困难。

## 富文本编辑器

可以考虑用带实时预览和cheatsheet的markdown编辑器来替代，字体颜色等可以通过内嵌html的方式解决。

## gRPC

基于protobuf和http2的RPC工具。

和RESTful API类似，适用于对外的接口。

## sass/scss

使用时，要么依赖ruby运行时（windows上没有内置），要么会遭遇到安装node-sass的各种问题。

## vuejs,angular,reactjs的animation或transition接口

完全可以使用css3的原生animation或transition来做，动画开始时设置class，动画结束（通过延时来判断）后替换成新class。

## postMessage API

是浏览器的跨源窗口间的通信接口；

监听事件时，需要验证origin和source，过滤掉危险网站发送的消息。

## next.js

服务端reactjs程序

缺点：前后端没有分离，各自不好扩展；与now联系紧密

好的免费solution有很多，不至于要用这个

## http/2 server push

目的是用于推送资源，而不是数据推送

目前nginx还不支持

如果某些资源用户不会用到，把它推给用户会浪费带宽

需要浏览器支持，所以需要后备手段

## angular的pipe和vuejs的filter

不推荐使用，用getter替代，除非是内置的，或者非常简单的转换。

## fuse-box

与webpack类似的前端打包工具，比起webpack，目前还不够成熟。

## sw-precache

用于生成service worker代码，不过生成的代码中含有大量的版权信息和注释，使用时还需要uglify生成的代码。

## push API

用于从服务器向处于后台的web app推送消息

浏览器支持问题，chrome目前还不支持

## egg

基于koa的插件化框架，缺点同koa；

可能是KPI的产物；

对除HTTP外的协议，例如websocket，支持不好；

根据技术选型的正交原则，尽量不要采用这样大而全类型的框架。

## lerna

当一个仓库内，会publish多个npm包时，lerna可以简化管理过程。

## yarn

相比node自带的npm，yarn提高了包恢复速度（离线、失败重试），并使包之间的依赖具有确定性，可以避免复杂依赖情况下，依赖结构不一致导致的BUG。

## Kafka

性能比ActiveMQ等传统的消息队列高

## protobuf, json, bson

传输用protobuf：因为protobuf的数据中不包含字段消息，所以会更小一些

公开API用json：因为json数据是字符串，可读性更好，对API的调用更友好

存储用bson：bson基于json，并针对存储做了改进

关于数据验证：protobuf在解析时会根据schema自行验证；而json和bson需要在解析完成后，再用json schema验证，需要额外维护一份json schema

## WebAssemply

目前发布了一个RC，主流浏览器也开启了preview性支持，到2017年第1季度结束时，将会确定draft规范，浏览器随之开始正式支持了，可见进度还是非常快的。

对由C++编译到WebAssemply的支持、WebAssemply和js的交互API会最先被支持

浏览器中一部分性能敏感的代码很可能会用C++来编写，再编译成WebAssemply

nodejs中一部分性能敏感的代码，之前会用C++来编写，再通过node-gyp编译成平台相关的二进制被使用，之后，C++代码可能会被编译成WebAssemply来供nodejs使用

## WebRTC

连接建立时不稳定，可以长到好几秒钟

目前不支持发送Blob对象，需要转换成Uint8Array发送

发送大体积数据时，会被拆分成多个数据包发送，接收方需要手动合并，数据体积过大时会直接报错

数据发送语句是异步的，但是数据发送过程可能会阻塞UI刷新，它是在UI线程下执行的

目前RTCDataChannel还不能在WebWorker下工作，不过目前是有proposal的，目前还没有进入标准，也没有浏览器实现，所以还需要等一段时间。

## angular2

目前依赖太多，包太大，tree-shaking在涉及到第三方库时基本不可用

数据更新机制复杂，涉及到zonejs、更新策略，遇到过多次数据更新了但UI没有更新的问题

## comet

是一类基于http协议的hack技术，常用于实时推送。

以发展的眼光看，会不可避免地被websocket替代掉。

## coffeescript

+ 目前不支持ES6
+ 目前没有支持ES6的计划

## serverless framework

+ 目前只有aws和azure支持
+ 不支持websocket

## koa

目前（2016-09）koa存在两个不兼容的版本：v1.x和v2.x

前者是稳定版本，使用generator，后者目前是alpha版本，使用async/await

在koa的迁移指南中，建议把generator替换成promise，以方便迁移

在async/await被node原始支持之前（2016.10左右），koa v2.x都将会是alpha状态

如果采用v1.x，以后会面临升级到v2.x的问题

如果采用v2.x，需要等待async/await被node原始支持，之后还要等待相关的中间件同步升级到和v2.x匹配的程度

所以，目前不是在生产环境采用koa的好时机

而express.js，中间件更丰富，升级平滑，对promise友好，对async/await友好，是目前nodejs上http框架的更好选择。

## react, react-router, redux

首先是react，更新频率正常，单独用的话没什么问题

react-router，接口变化太快了，每次都是breaking change

redux，和react和react-router配合时，还需要引入react-redux和react-router-redux，依赖太多了

如果单独用，难以处理嵌套的数据模型

## nodejs ORM

目前nodejs的各个ORM库都不是统治地位，结果可能在一个项目使用Sequelize，在另一个项目可能使用orm2，导致学习成本翻倍。

目前的ORM需要引入一个库，为每个模型写model，写映射，这样增加额外的代码，可能引入额外的BUG。

因为js是弱类型语言，ORM带来的对SQL的检查效果不如java/C#这类强类型语言，所以在实际使用时会感觉到没那么有用。

从优化SQL执行效率的角度，ORM的效率上限比不上原生SQL的效率上限。

目前主流关系型数据库都在进化，例如开始可以存储json（例如mysql 5.7之后的`json_extract`和`json_set`），目前这些ORM还不支持这样的特性。

更推荐的做法是，使用原生sql语句，再把查询结果映射到js对象，这时候使用类型直接标注就可以做到了。

## docker

以nodejs程序角度，会打包nodejs、应用程序、node_modules，所以体积会很大。即使只改动了几行代码，也要更新几百MB的镜像。

需要建私有仓库，来保证权限控制。

最大的优点是，部署时不用担心依赖之间的冲突，当依赖复杂时，会很省心。

## 前端框架的服务端渲染特性

会增加前后端偶合度、复杂度、后端压力。

因为代码都会在前后端被执行，所以代码中不能使用浏览器端才有的接口，例如window、document。

目的一般是为了SEO，但是一般内容型的网站才有SEO需求（非内容型的网站，例如邮箱、OA，没有SEO需求），一般内容型的网站的待SEO的内容（博客正文、新闻、回答）的业务逻辑相对较简单，可以在服务端渲染，而其它不需要SEO的内容（例如评论框、点赞按钮、转发按钮），则可以在页面加载完成后在前端渲染。

## 热更新

会增加复杂度，需要考虑其必要性。

后端如果有负载均衡机制，而且程序内不会有持久数据，可以通过控制各个程序的权值，先控制部分程序逐渐减少为0负载，更新后重启，再提高其权重，最终所有程序逐步实现热更新。

## mobx

常和react配合，是redux之外的另一个选择。

## cyclejs

优点：rxjs, typescript

缺点：目前小众，支持jsx但需要babel来支持到tsx

## rust

优点：性能、语言特性和抽象

缺点：目前小众，开发体验还不够好，编辑器支持程度低，学习曲线太陡了，开发效率低

## java

优点：语法简单易学；程序运行效率较高，且稳定；招人容易

缺点：语言表达能力弱，有的简单问题需要大量的代码才能实现；java项目有过度设计的倾向，滥用设计模式，过度封装，导致代码膨胀；程序设计时倾向于大量使用配置文件，降低了开发和维护效率。
