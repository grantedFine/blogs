## angular的pipe和vuejs的filter

不推荐使用，用getter替代，除非是内置的，或者非常简单的转换。

## fuse-box

与webpack类似的前端打包工具，比起webpack，目前还不够成熟。

## sw-precache

用于生成service worker代码，不过生成的代码中含有大量的版权信息和注释，使用时还需要uglify生成的代码；在手写service worker代码时，可以参考它生成的代码。

## push API

用于从服务器向处于后台的web app推送消息

浏览器支持问题，chrome目前还不支持

## egg

基于koa的插件化框架，缺点同koa；

可能是KPI的产物；

对除HTTP外的协议，例如websocket，支持不好；

根据技术选型的正交原则，尽量不要采用这样大而全类型的框架。

## lerna

当一个仓库内，会publish多个npm包时，lerna可以简化管理过程。

## yarn

相比node自带的npm，yarn提高了包恢复速度（离线、失败重试），并使包之间的依赖具有确定性，可以避免复杂依赖情况下，依赖结构不一致导致的BUG。

## Kafka

性能比ActiveMQ等传统的消息队列高

## protobuf, json, bson

传输用protobuf：因为protobuf的数据中不包含字段消息，所以会更小一些

公开API用json：因为json数据是字符串，可读性更好，对API的调用更友好

存储用bson：bson基于json，并针对存储做了改进

关于数据验证：protobuf在解析时会根据schema自行验证；而json和bson需要在解析完成后，再用json schema验证，需要额外维护一份json schema

## WebAssemply

目前发布了一个RC，主流浏览器也开启了preview性支持，到2017年第1季度结束时，将会确定draft规范，浏览器随之开始正式支持了，可见进度还是非常快的。

对由C++编译到WebAssemply的支持、WebAssemply和js的交互API会最先被支持

浏览器中一部分性能敏感的代码很可能会用C++来编写，再编译成WebAssemply

nodejs中一部分性能敏感的代码，之前会用C++来编写，再通过node-gyp编译成平台相关的二进制被使用，之后，C++代码可能会被编译成WebAssemply来供nodejs使用

## WebRTC

连接建立时不稳定，可以长到好几秒钟

目前不支持发送Blob对象，需要转换成Uint8Array发送

发送大体积数据时，会被拆分成多个数据包发送，接收方需要手动合并，数据体积过大时会直接报错

数据发送语句是异步的，但是数据发送过程可能会阻塞UI刷新，它是在UI线程下执行的

目前RTCDataChannel还不能在WebWorker下工作，不过目前是有proposal的，目前还没有进入标准，也没有浏览器实现，所以还需要等一段时间。

## angular2

目前依赖太多，包太大，tree-shaking在涉及到第三方库时基本不可用

数据更新机制复杂，涉及到zonejs、更新策略，遇到过多次数据更新了但UI没有更新的问题

## comet

是一类基于http协议的hack技术，常用于实时推送。

以发展的眼光看，会不可避免地被websocket替代掉。

## coffeescript

+ 目前不支持ES6
+ 目前没有支持ES6的计划

## serverless framework

+ 目前只有aws和azure支持
+ 不支持websocket

## koa

目前（2016-09）koa存在两个不兼容的版本：v1.x和v2.x

前者是稳定版本，使用generator，后者目前是alpha版本，使用async/await

在koa的迁移指南中，建议把generator替换成promise，以方便迁移

在async/await被node原始支持之前（2016.10左右），koa v2.x都将会是alpha状态

如果采用v1.x，以后会面临升级到v2.x的问题

如果采用v2.x，需要等待async/await被node原始支持，之后还要等待相关的中间件同步升级到和v2.x匹配的程度

所以，目前不是在生产环境采用koa的好时机

而express.js，中间件更丰富，升级平滑，对promise友好，对async/await友好，是目前nodejs上http框架的更好选择。

## react, react-router, redux

首先是react，更新频率正常，单独用的话没什么问题

react-router，接口变化太快了，每次都是breaking change

redux，和react和react-router配合时，还需要引入react-redux和react-router-redux，依赖太多了

如果单独用，难以处理嵌套的数据模型

## nodejs ORM

目前nodejs的各个ORM库都不是统治地位，结果可能在一个项目使用Sequelize，在另一个项目可能使用orm2，导致学习成本翻倍。

目前的ORM需要引入一个库，为每个模型写model，写映射，这样增加额外的代码，可能引入额外的BUG。

因为js是弱类型语言，ORM带来的对SQL的检查效果不如java/C#这类强类型语言，所以在实际使用时会感觉到没那么有用。

从优化SQL执行效率的角度，ORM的效率上限比不上原生SQL的效率上限。

目前主流关系型数据库都在进化，例如开始可以存储json（例如mysql 5.7之后的`json_extract`和`json_set`），目前这些ORM还不支持这样的特性。

更推荐的做法是，使用原生sql语句，再把查询结果映射到js对象，这时候使用类型直接标注就可以做到了。

## docker

以nodejs程序角度，会打包nodejs、应用程序、node_modules，所以体积会很大。即使只改动了几行代码，也要更新几百MB的镜像。

需要建私有仓库，来保证权限控制。

最大的优点是，部署时不用担心依赖之间的冲突，当依赖复杂时，会很省心。

## 服务端渲染

会增加前后端偶合度、复杂度、后端压力，需要考虑其必要性。

## 热更新

会增加复杂度，需要考虑其必要性。

后端如果有负载均衡机制，而且程序内不会有持久数据，可以通过控制各个程序的权制，先控制部分程序逐渐减少为0负载，更新后重启，再提高其权重，最终所有程序逐步实现热更新。

## mobx

常和react配合，是redux之外的另一个选择。

## cyclejs

优点：rxjs, typescript

缺点：目前小众，支持jsx但需要babel来支持到tsx

## rust

优点：性能、语言特性和抽象

缺点：目前小众，开发体验还不够好，编辑器支持程度低，学习曲线太陡了，开发效率低

## java

优点：语法简单易学；程序运行效率较高，且稳定；招人容易

缺点：语言表达能力弱，有的简单问题需要大量的代码才能实现；java项目有过度设计的倾向，滥用设计模式，过度封装，导致代码膨胀；程序设计时倾向于大量使用配置文件，降低了开发和维护效率。
