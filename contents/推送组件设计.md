#### 目标

+ 需要支持单一推送、分组推送、全局广播
+ 支持多种连接，例如UDP、TCP、WebSocket
+ 启动后，分组可以改变
+ 推送失败后支持多种策略，例如丢弃数据、延迟几次后重发、告警、消息持久化

#### 一种实现思路

+ 提供`subscribe`接口，在客户端建立连接后订阅需要的消息，或动态订阅更多的消息
+ 提供`unsubscribe`接口，在客户端的连接断开后取消自己所有的订阅，或动态取消已有的订阅
+ 提供`publish`接口，为数据源提供数据发布服务

#### 相应的代码

```ts
type Handle = (message: any) => void;

const mapper = new Map<string, Set<Handle>>();

function subscribe(tagName: string, handle: Handle) {
    let handlers = mapper.get(tagName);
    if (!handlers) {
        handlers = new Set<Handle>();
        mapper.set(tagName, handlers);
    }
    handlers.add(handle);
}

export function subscribeGroup(groupName: string, groupId: string | number, handle: Handle) {
    subscribe(`${groupName}_${groupId}`, handle);
}

export function subscribeGroups(groupName: string, groupIds: (string | number)[], handle: Handle) {
    for (const groupId of groupIds) {
        subscribeGroup(groupName, groupId, handle);
    }
}

export function subscribeGlobal(handle: Handle) {
    subscribe("*", handle);
}

function unsubscribe(tagName: string, handle: Handle) {
    const handles = mapper.get(tagName);
    if (handles) {
        handles.delete(handle);
        if (handles.size === 0) {
            mapper.delete(tagName);
        }
    }
}

export function unsubscribeGroup(groupName: string, groupId: string | number, handle: Handle) {
    unsubscribe(`${groupName}_${groupId}`, handle);
}

export function unsubscribeGroups(groupName: string, groupIds: (string | number)[], handle: Handle) {
    for (const groupId of groupIds) {
        unsubscribeGroup(groupName, groupId, handle);
    }
}

export function unsubscribeGlobal(handle: Handle) {
    unsubscribe("*", handle);
}

function publish(tagName: string, message: any) {
    let handlers = mapper.get(tagName);
    if (handlers) {
        for (const handle of handlers) {
            handle(message);
        }
    }
}

export function publishToGroup(groupName: string, groupId: string | number, message: any) {
    publish(`${groupName}_${groupId}`, message);
}

export function publishToGlobal(message: any) {
    publish("*", message);
}
```

#### 使用场景

某用户的id是100，关注topic a，订阅操作如下：

```ts
import * as pusher from "./pusher";

function handle1(message: any) {
    console.log(`user 100 accepted: ${message}`);
}
pusher.subscribeGroup("userid", 100, handle1);
pusher.subscribeGroup("topic", "a", handle1);
pusher.subscribeGlobal(handle1);
```

某用户的id是101，也关注topic a，订阅操作如下：

```ts
function handle2(message: any) {
    console.log(`user 101 accepted: ${message}`);
}
pusher.subscribeGroup("userid", 101, handle2);
pusher.subscribeGroup("topic", "a", handle2);
pusher.subscribeGlobal(handle2);
```

某用户的id是102，关注topic b，订阅操作如下：

```ts

function handle3(message: any) {
    console.log(`user 102 accepted: ${message}`);
}
pusher.subscribeGroup("userid", 102, handle3);
pusher.subscribeGroup("topic", "b", handle3);
pusher.subscribeGlobal(handle3);
```

当数据源希望向用户100推送数据，推送操作如下：

```ts
pusher.publishToGroup("userid", 100, "a message to user 100 only");
```

结果提示：

```bash
user 100 accepted: a message to user 100 only
```

当数据源希望向topic a推送数据，推送操作如下：

```ts
pusher.publishToGroup("topic", "a", "a message to topic a");
```

结果提示：

```bash
user 100 accepted: a message to topic a
user 101 accepted: a message to topic a
```

当数据源希望向所有连接推送数据，推送操作如下：

```ts
pusher.publishToGlobal("a message to all users");
```

结果提示：

```bash
user 100 accepted: a message to all users
user 101 accepted: a message to all users
user 102 accepted: a message to all users
```

#### TCP连接的场景

```ts
import * as net from "net";
net.createServer(socket => {
    // todo: validate user permission, get use id, and the topics he is interested in
    const userId = 103;
    const topics = ["c", "d"];
    function handle(message: any) {
        socket.emit("data", message);
    }
    pusher.subscribeGroup("userid", userId, handle);
    pusher.subscribeGroups("topic", topics, handle);
    pusher.subscribeGlobal(handle);
    socket.on("close", hadError => {
        pusher.unsubscribeGroup("userid", userId, handle);
        pusher.unsubscribeGroups("topic", topics, handle);
        pusher.unsubscribeGlobal(handle);
    });
}).listen(8000);
```

#### WebSocket连接的场景

```ts
import * as ws from "ws";
ws.createServer({ port: 8000 }, ws => {
    // todo: validate user permission, get use id, and the topics he is interested in
    const userId = 103;
    const topics = ["c", "d"];
    function handle(message: any) {
        ws.send(message);
    }
    pusher.subscribeGroup("userid", userId, handle);
    pusher.subscribeGroups("topic", topics, handle);
    pusher.subscribeGlobal(handle);
    ws.on("close", code => {
        pusher.unsubscribeGroup("userid", userId, handle);
        pusher.unsubscribeGroups("topic", topics, handle);
        pusher.unsubscribeGlobal(handle);
    });
});
```

#### 消息推送失败时的处理策略

```ts
function handle(message: any) {
    // 1st try
    ws.send(message, error1 => {
        if (error1) {
            setTimeout(() => {
                // 2nd try
                ws.send(message, error2 => {
                    if (error2) {
                        setTimeout(() => {
                            // 3rd try
                            ws.send(message, error3 => {
                                if (error3) {
                                    // alarm or persist data to database
                                }
                            });
                        }, 1000);
                    }
                });
            }, 1000);
        }
    });
}
```
