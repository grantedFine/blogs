把所有东西都写在html文件中应该是最原始的前端了：

```c
index.html
```

### html/css/js分离

分离后的目录结构如下：

```c
index.html
// changes start
scripts
    index.js
styles
    index.css
// changes end
```

其中html文件里类似于：

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <link href="styles/index.css" rel="stylesheet">
  </head>
  <body>
    <script src="scripts/index.js"></script>
  </body>
</html>
```

### 如果要引入第三方文件

可以通过bower/npm安装到本地，或直接使用CDN地址。

以主流的npm方式为例，如果引入bootstrap，html文件变成：

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <!--changes start-->
    <link href="./node_modules/bootstrap/3.3.6/css/bootstrap.min.css" rel="stylesheet">
    <link href="./node_modules/bootstrap/3.3.6/css/bootstrap-theme.min.css" rel="stylesheet">
    <!--changes end-->
    <link href="styles/index.css" rel="stylesheet">
  </head>
  <body>
    <!--changes start-->
    <script src="./node_modules/jquery/2.2.0/jquery.min.js"></script>
    <script src="./node_modules/bootstrap/3.3.6/js/bootstrap.min.js"></script>
    <!--changes end-->
    <script src="scripts/index.js"></script>
  </body>
</html>
```

在这个阶段，一般需要自定义一个npm命令来把node_modules中的文件复制出来。

### 如果要给css和js加上版本

除了可以借助后端之外，前端可用的方案有grunt-rev、gulp-rev、webpack的long term caching。

webpack的方案目前只能给js文件加上版本，如果css不想被打包进去，还要找其它的方案来处理css。

这里以rev-static为例，在js/css文件名上加版本，并修改html文件中对应的文件名。

下面是`rev-static.config.js`文件：

```js
module.exports = {
    inputFiles: [
        "styles/index.css",
        "scripts/index.js",
        "index.ejs.html"
    ],
    outputFiles: [
        "index.html"
    ],
    json: false,
    ejsOptions: {
        rmWhitespace: false
    },
    sha: 256,
    customNewFileName: (filePath, fileString, md5String, baseName, extensionName) => baseName + "-" + md5String + extensionName,
}
```

这里需要把`index.html`文件的文件名修改为`index.ejs.html`：

```c
// changes start
index.ejs.html
// changes end
scripts
    index.js
styles
    index.css
```

内容修改为：

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <link href="./node_modules/bootstrap/3.3.6/css/bootstrap.min.css" rel="stylesheet">
    <link href="./node_modules/bootstrap/3.3.6/css/bootstrap-theme.min.css" rel="stylesheet">
    <!--changes start-->
    <link href="styles/<%=stylesIndexCss%>" rel="stylesheet">
    <!--changes end-->
  </head>
  <body>
    <script src="./node_modules/jquery/2.2.0/jquery.min.js"></script>
    <script src="./node_modules/bootstrap/3.3.6/js/bootstrap.min.js"></script>
    <!--changes start-->
    <script src="scripts/<%=scriptsIndexJs%>"></script>
    <!--changes end-->
  </body>
</html>
```

执行`rev-static`后的目录结构如下：

```c
// changes start
index.html
// changes end
scripts
    index.js
    // changes start
    index-caa02e8ba0c5af68e9ac7728da2bed75.js
    // changes end
styles
    index.css
    // changes start
    index-f695dca31d31e7c85e3442e5ca88da6d.css
    // changes end
```

其中`index.html`的内容为：

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <link href="./node_modules/bootstrap/3.3.6/css/bootstrap.min.css" rel="stylesheet">
    <link href="./node_modules/bootstrap/3.3.6/css/bootstrap-theme.min.css" rel="stylesheet">
    <!--changes start-->
    <link href="styles/index-f695dca31d31e7c85e3442e5ca88da6d.css" rel="stylesheet">
    <!--changes end-->
  </head>
  <body>
    <script src="./node_modules/jquery/2.2.0/jquery.min.js"></script>
    <script src="./node_modules/bootstrap/3.3.6/js/bootstrap.min.js"></script>
    <!--changes start-->
    <script src="scripts/index-caa02e8ba0c5af68e9ac7728da2bed75.js"></script>
    <!--changes end-->
  </body>
</html>
```

这样版本化就完成了。

### 如果js变得复杂，需要模块化

常见的前端js模块化方式有commonjs和AMD，相应的工具是webpack/browserify和require.js/webpack。

采用哪种方式往往会受到采用的前端框架影响。例如对于react和相关的工具链，官方推荐commonjs，vuejs也是官方推荐commonjs，而对于angular2，官方推荐system.js，当然也可以不用推荐的方式。

下面以用webpack打包commonjs模块为例，部分目录结构如下：

```c
scripts
    index.js
    // changes start
    a.js
    b.js
    // changes end
```

下面是webpack的配置文件，`webpack.config.js`文件：

```javascript
const webpack = require("webpack");
const path = require("path");

module.exports = {
    entry: {
        index: "scripts/index"
    },
    output: {
        path: path.join(__dirname, "scripts"),
        filename: "[name].bundle.js"
    }
};
```

运行`webpack`后，生成`scripts/index.bundle.js`，目录结构如下：

```c
scripts
    index.js
    a.js
    b.js
    // changes start
    index.bundle.js
    // changes end
```

这时`index.bundle.js`取代`index.js`，成为js的入口文件，`index.ejs.html`、`rev-static.config.js`中都有做相应的更新。

### 使用lint控制代码格式

以ESlint和css lint为例，直接执行相应的CLI命令即可。

npm脚本变成：

```js
{
    "build": "npm run lint && webpack && rev-static",
    "lint": "eslint scripts/*.js && csslint styles/*.css"
}
```

执行`npm run build`即可把这几个构建过程串联起来。

### css、js、html的压缩

js可以用webpack的插件来压缩，css可以用cleancss来压缩，html可以用rev-static来压缩：

下面是`rev-static.config.js`文件：

```js
module.exports = {
    inputFiles: [
        "styles/index.bundle.css",
        "scripts/index.bundle.js",
        "index.ejs.html"
    ],
    outputFiles: [
        "index.html"
    ],
    json: false,
    ejsOptions: {
        // changes start
        "rmWhitespace": true
        // changes end
    },
    sha: 256,
    customNewFileName: (filePath, fileString, md5String, baseName, extensionName) => baseName + "-" + md5String + extensionName,
}
```

下面是webpack的配置文件，`webpack.config.js`文件：

```javascript
const webpack = require("webpack");
const path = require("path");

module.exports = {
    entry: {
        index: "scripts/index"
    },
    output: {
        path: path.join(__dirname, "scripts"),
        filename: "[name].bundle.js"
    },
    // changes start
    plugins: [
        new webpack.optimize.UglifyJsPlugin({
            compress: {
                warnings: false,
            },
            output: {
                comments: false,
            },
        })
    ]
    // changes end
};
```

npm脚本变成：

```js
{
    // changes start
    "build": "npm run lint && webpack && npm run cleancss && rev-static",
    // changes end
    "lint": "eslint scripts/*.js && csslint styles/*.css",
    // changes start
    "cleancss": "cleancss styles/index.css -o styles/index.bundle.css"
    // changes end
}
```

这时`index.bundle.css`取代`index.css`，成为css的入口文件，`index.ejs.html`、`rev-static.config.js`中都要做相应的更新。

### 如果使用LESS或SCSS，并编译成css

以SCSS为例，可以执行shell命令：`sass styles/index.scss > build/index.css`，scss-lint也可以以命令的形式执行`scss-lint styles/*.scss`：

npm脚本变成：

```js
{
    "build": "npm run lint && webpack && npm run cleancss && rev-static",
    // changes start
    "lint": "eslint scripts/*.js && scss-lint styles/*.css",
    "cleancss": "sass styles/index.scss > styles/index.css && cleancss styles/index.css -o styles/index.bundle.css"
    // changes end
}
```

### 如果使用css后处理器工具

如果支持最新的2个浏览器版本：

配置文件`postcss.json`是：

```
{
    "autoprefixer": {
        "browsers": ["last 2 versions"]
    }
}
```

npm脚本变成：

```js
{
    "build": "npm run lint && webpack && npm run cleancss && rev-static",
    "lint": "eslint scripts/*.js && scss-lint styles/*.css",
    // changes start
    "cleancss": "sass styles/index.scss > styles/index.css && postcss --use autoprefixer -c postcss.json -o styles/index.css styles/index.css && cleancss styles/index.css -o styles/index.bundle.css"
    // changes end
}
```

### 如果写ES6代码，并编译成ES5

这里以babel为例：

配置文件是：

```
{
    presets: ["es2015"]
}
```

npm脚本变成：

```js
{
    // changes start
    "build": "babel && npm run lint && webpack && npm run cleancss && rev-static",
    // changes end
    "lint": "eslint scripts/*.js && scss-lint styles/*.css",
    "cleancss": "sass styles/index.scss > styles/index.css && postcss --use autoprefixer -c postcss.json -o styles/index.css styles/index.css && cleancss styles/index.css -o styles/index.bundle.css"
}
```

### 如果使用typescript或coffeescript，并编译成ES5

这里以typescript为例：

配置文件为：

```json
{
    "compilerOptions": {
        "module": "commonjs",
        "target": "es5"
    }
}
```

npm脚本变成：

```js
{
    // changes start
    "build": "tsc && npm run lint && webpack && npm run cleancss && rev-static",
    // changes end
    "lint": "eslint scripts/*.js && scss-lint styles/*.css",
    "cleancss": "sass styles/index.scss > styles/index.css && postcss --use autoprefixer -c postcss.json -o styles/index.css styles/index.css && cleancss styles/index.css -o styles/index.bundle.css"
}
```

### 第三方大文件独立打包

以react和react-router为例，它们都要通过npm安装，默认会被打包进去。

需要把它们打包到vendor中，这样当程序变化时，vendor的变化频率不会很大。

```c
scripts
    index.js
    a.js
    b.js
    index.bundle.js
    // changes start
    vendor.js
    // changes end
```

其中`vendor.js`：

```
import "react";
import "react-router";
```

下面是webpack的配置文件，`webpack.config.js`文件：

```javascript
const webpack = require("webpack");
const path = require("path");

module.exports = {
    entry: {
        index: "scripts/index",
        // changes start
        vendor: "scripts/vendor"
        // changes end
    },
    output: {
        path: path.join(__dirname, "scripts"),
        filename: "[name].bundle.js"
    },
    plugins: [
        // changes start
        new webpack.optimize.DedupePlugin(),
        // changes end
        new webpack.optimize.UglifyJsPlugin({
            compress: {
                warnings: false,
            },
            output: {
                comments: false,
            },
        }),
        // changes start
        new webpack.optimize.CommonsChunkPlugin({
            name: ["index", "vendor"]
        })
        // changes end
    ]
};
```

对于CSS，cleancss可以用于合并第三方包：

npm脚本变成：

```js
{
    "build": "babel && npm run lint && webpack && npm run cleancss && rev-static",
    "lint": "eslint scripts/*.js && scss-lint styles/*.css",
    // changes start
    "cleancss": "sass styles/index.scss > styles/index.css && postcss --use autoprefixer -c postcss.json -o styles/index.css styles/index.css && cleancss styles/index.css -o styles/index.bundle.css && cleancss node_modules/bootstrap/dist/css/bootstrap.min.css node_modules/bootstrap/dist/css/bootstrap-theme.min.css > styles/vendor.css"
    // changes end
}
```

另外对于bootstrap，还需要复制一下字体文件，到发布目录，并保持css和字体文件的相对位置一致。

### 从js文件中抽出模板

js文件中经常会有模版（例如在vuejs和angular中），模板直接写在js中，一般没有语法高亮，容易出错。为了避免这个问题，可以把模板字符串抽取到独立的html模板文件中，再利用代码打包工具（例如webpack的raw-loader）在打包时加载模板。

```ts
@Component({
   template: require("raw-loader!./foo.html"),
})
class Bar extends Vue { }
```

模板文件分离后，可以利用`html-minifier`等消除模板中无效的换行和空格，以减少模板的大小：

```bash
html-minifier --collapse-whitespace --case-sensitive --collapse-inline-tag-whitespace foo.template.html -o foo.html
```

在制作组件库时，不希望依赖`raw-loader`这样的模板加载工具（因为使用方不一定使用webpack来打包），可以利用`file2variable-cli`来把模板文件转换为ES6文件：

```bash
file2variable-cli foo.html -o foo-variables.js
```

执行后，生成类似如下的js文件：

```js
export const fooHtml = `<span>{{foo}}</span>`;
```

模板的使用过程也就变为：

```ts
import { fooHtml } from "./foo-variables";

@Component({
   template: fooHtml,
})
class Bar extends Vue { }
```

### 打包时，把小图标转为base64格式，并内联到css文件中

这样做的话，可以在加载时减少http请求数。而具体的方法，可以使用`image2base64-cli`来实现：

```bash
image2base64-cli images/*.png --less variables.less
```

生成的less文件类似于：

```less
@foo-png: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAMAAABEpIrGAAAAM1BMVEUAAAAAAAAAAAAAAAAAAAADAwMEBAQAAADHx8e1tbUAAAD////p6enz8/P39/f7+/vu7u5nZ34DAAAAC3RSTlMAMTwMGE8rBqWkYZ+r9QEAAACPSURBVDjL7ZJbDoMgEADdF2oXhfuftksogcA2PUCdL5cZQwhsf8bOATqB9zngQ0cOnoOg0n5HRNEwB6Dw+SJURAUvaF5V3KD5rwExVe9vUVaRqyfwAjH1qn7zg5RuI5l3g4R4FcyXaQ1uIMw5I9VpDS6wI0TzdVqDbEt20D5NhCjQkbjcBZ9x5OTf7+Fh5A1DkAXNMEdnOQAAAABJRU5ErkJggg==';
@bar-png: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgBAMAAACBVGfHAAAAIVBMVEUAAAAAAAAAAAAAAAAAAAABAQH////7+/v39/fy8vLr6+sN7QgRAAAABnRSTlMADD0xGCVFoQlVAAAAQklEQVQoz2MYakBEAE0gTBFNwCxJAE2gTBFNIA2qBCGQpogukIIiYF5ejqrCoqMJ1QzLmWi2WC1Cc0eUIqZfBjsAAO4ACr4wbS2OAAAAAElFTkSuQmCC';
```

在使用时，就可以使用这些变量了：

```less
@import "./variables.less";

.foo {
  background-image: url("@{foo-png}");
}
.bar {
  background-image: url("@{bar-png}");
}
```
