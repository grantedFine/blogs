主要效果是：

1. 后端只提供API，独立的代码，独立部署，可能会有多个域名，例如https://example.com/api/ 和https://api.example.com/
2. 前端自己渲染，提供html/js/css等，独立的代码，独立部署，通过https://example.com/ 访问

### 前端web server用nginx

这是一个常见的方案，如果前端文件在`/opt/static`，则nginx的配置文件类似：

```nginx
    server {
        listen       80;
        listen       [::]:80;
        server_name example.com www.example.com;

        location ~*\.(js|css|jpg|jpeg|gif|png|ico|cur|gz|svg|svgz|map|mp4|ogg|ogv|webm|htc|json|ttf|woff)$ {
            root         /opt/static;
            expires 1M;
            access_log off;
            add_header Cache-Control public;
        }
        location ~*\.html$ {
            root         /opt/static;
            index index.html;
            access_log off;
        }
    }
```

这里html和其它文件不同在于：Cache-Control是不一样的，html文件一般不会加版本控制，更新时会改变文件的更新时间，所以可以采用默认策略；而其它文件，一般是在文件名上加版本控制，或者创建后就不再变化，这样使用public要更好一些。

### 配置https和http2.0

https正在普及，成本也不高。如果crt和key文件分别放在`/opt/1.crt`和`/opt/1.key`，配置会变成：

```nginx
    server {
        # changes start
        listen       443 ssl http2;
        listen       [::]:443;
        ssl on;
        ssl_certificate /opt/1.crt;
        ssl_certificate_key /opt/1.key;
        # changes end
        server_name example.com www.example.com;

        location ~*\.(js|css|jpg|jpeg|gif|png|ico|cur|gz|svg|svgz|map|mp4|ogg|ogv|webm|htc|json|ttf|woff)$ {
            root         /opt/static;
            expires 1M;
            access_log off;
            add_header Cache-Control public;
        }
        location ~*\.html$ {
            root         /opt/static;
            index index.html;
            access_log off;
        }
    }
```

其中nginx在1.9.5 之后才支持http2.0，如果nginx版本不够，要去掉`http2`。

### 加上后端

后端需要自己监听一个端口，以node为例，可以以pm2/forever运行，监听localhost:3000，这时候就需要nginx反代这个服务：

```nginx
    # changes start
    upstream backend {
        server localhost:3000;
    }
    # changes end
    server {
        listen       443 ssl http2;
        listen       [::]:443;
        ssl on;
        ssl_certificate /opt/1.crt;
        ssl_certificate_key /opt/1.key;
        server_name example.com www.example.com;

        location ~*\.(js|css|jpg|jpeg|gif|png|ico|cur|gz|svg|svgz|map|mp4|ogg|ogv|webm|htc|json|ttf|woff)$ {
            root         /opt/static;
            expires 1M;
            access_log off;
            add_header Cache-Control public;
        }
        location ~*\.html$ {
            root         /opt/static;
            index index.html;
            access_log off;
        }
        # changes start
        location / {
            proxy_pass http://backend;
        }
        # changes end
    }
```

这时候目标都已完成。

### 如果使用了socket.io

nginx是支持websocket的，可以观察到socket.io的通信url形式是`/socket.io/*`。这时候的配置：

```nginx
    upstream backend {
        server localhost:3000;
    }
    # changes start
    map $http_upgrade $connection_upgrade {
        default upgrade;
        '' close;
    }
    # changes end
    server {
        listen       443 ssl http2;
        listen       [::]:443;
        ssl on;
        ssl_certificate /opt/1.crt;
        ssl_certificate_key /opt/1.key;
        server_name example.com www.example.com;

        # changes start
        location ~*/socket.io/* {
            proxy_pass http://backend;
            proxy_http_version 1.1;
            proxy_set_header Upgrade $http_upgrade;
            proxy_set_header Connection "Upgrade";
        }
        # changes end
        location ~*\.(js|css|jpg|jpeg|gif|png|ico|cur|gz|svg|svgz|map|mp4|ogg|ogv|webm|htc|json|ttf|woff)$ {
            root         /opt/static;
            expires 1M;
            access_log off;
            add_header Cache-Control public;
        }
        location ~*\.html$ {
            root         /opt/static;
            index index.html;
            access_log off;
        }
        location / {
            proxy_pass http://backend;
        }
    }
```

### 跨域问题

主要有两种解决方案，jsonp和cors，jsonp本质上是get一个js script，优点是浏览器支持度好，缺点是只支持GET，而cors可以支持GET/POST/PUT/DELETE等等，但IE6不支持cors。

跨域问题主要靠后端来处理，以node为例，可以使用库https://www.npmjs.com/package/cors ，把支持跨域的域名加入配置就好。

如果跨域，请求是默认不带cookie的，如果需要，可以在前端设置，以jquery为例：

```javascript
$.ajaxSetup({
    xhrFields: {
        withCredentials: true
    }
});
```

### 前端开发环境的跨域问题

主要有三种解决方案，改host、使用fiddler script修改host和使用本地nginx，以后者为例，如果通过本地3000端口访问到的是https://example.com ：

```nginx
    map $http_upgrade $connection_upgrade {
        default upgrade;
        '' close;
    }
    server {
        listen       3000;
        server_name  localhost;

        location ~*/socket.io/* {
            proxy_pass https://example.com;
            proxy_http_version 1.1;
            proxy_set_header Upgrade $http_upgrade;
            proxy_set_header Connection "Upgrade";
        }

        location / {
            add_header Access-Control-Allow-Origin http://localhost:8000;
            proxy_pass https://example.com;
        }
    }
```

这里可以支持websocket，其中8000是前端页面的监听端口。

### 如果需要加入多个web server

强大的nginx就可以做到，还可以做负载均衡。

配置类似于：

```nginx
    upstream backend {
        server localhost:3000 weight=2;
        server localhost:3001 weight=1;
    }
```

### 如果前端是单页应用

这种情况，一般是前端切换路由时，URL变化了，如果没有特殊地处理，页面被刷新后，会出现404。

以react-router为例，同时假设前端路由都以`.html`结尾，nginx配置变成：

```nginx
    upstream backend {
        server localhost:3000;
    }
    map $http_upgrade $connection_upgrade {
        default upgrade;
        '' close;
    }
    server {
        listen       443 ssl http2;
        listen       [::]:443;
        ssl on;
        ssl_certificate /opt/1.crt;
        ssl_certificate_key /opt/1.key;
        server_name example.com www.example.com;

        location ~*/socket.io/* {
            proxy_pass http://backend;
            proxy_http_version 1.1;
            proxy_set_header Upgrade $http_upgrade;
            proxy_set_header Connection "Upgrade";
        }
        location ~*\.(js|css|jpg|jpeg|gif|png|ico|cur|gz|svg|svgz|map|mp4|ogg|ogv|webm|htc|json|ttf|woff)$ {
            root         /opt/static;
            expires 1M;
            access_log off;
            add_header Cache-Control public;
        }
        # changes start
        location ~*\.html$ {
            root         /opt/static;
            try_files $uri /index.html;
            access_log off;
        }
        location =/ {
            root         /opt/static;
            index index.html;
            access_log off;
        }
        # changes end
        location / {
            proxy_pass http://backend;
        }
    }
```

这里使用try_files，对于以`.html`结尾的路由，如果找不到文件，会返回`index.html`，react-router会根据当前URL路由到正确的组件。

### 如果后端需要获得客户端真实IP

这种情况，一般是后端需要根据真实IP，来限制API访问频率。

nginx配置变成：

```nginx
    upstream backend {
        server localhost:3000;
    }
    map $http_upgrade $connection_upgrade {
        default upgrade;
        '' close;
    }
    server {
        listen       443 ssl http2;
        listen       [::]:443;
        ssl on;
        ssl_certificate /opt/1.crt;
        ssl_certificate_key /opt/1.key;
        server_name example.com www.example.com;

        location ~*/socket.io/* {
            proxy_pass http://backend;
            proxy_http_version 1.1;
            proxy_set_header Upgrade $http_upgrade;
            proxy_set_header Connection "Upgrade";
        }
        location ~*\.(js|css|jpg|jpeg|gif|png|ico|cur|gz|svg|svgz|map|mp4|ogg|ogv|webm|htc|json|ttf|woff)$ {
            root         /opt/static;
            expires 1M;
            access_log off;
            add_header Cache-Control public;
        }
        location ~*\.html$ {
            root         /opt/static;
            try_files $uri /index.html;
            access_log off;
        }
        location =/ {
            root         /opt/static;
            index index.html;
            access_log off;
        }
        location / {
            proxy_pass http://backend;
            # changes start
            proxy_set_header        Host            $host;
            proxy_set_header        X-Real-IP       $remote_addr;
            proxy_set_header        X-Forwarded-For $proxy_add_x_forwarded_for;
            # changes end
        }
    }
```

这时，客户端真实IP存在于名为`X-Real-IP`或`X-Forwarded-For`的header中
